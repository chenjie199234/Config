// Code generated by protoc-gen-go-web. DO NOT EDIT.

package api

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	bufpool "github.com/chenjie199234/Corelib/bufpool"
	common "github.com/chenjie199234/Corelib/util/common"
	metadata "github.com/chenjie199234/Corelib/util/metadata"
	web "github.com/chenjie199234/Corelib/web"
	io "io"
	http "net/http"
	time "time"
)

var WebPathSconfigSinfo = "/config.Sconfig/Sinfo"
var WebPathSconfigSset = "/config.Sconfig/Sset"
var WebPathSconfigSrollback = "/config.Sconfig/Srollback"
var WebPathSconfigSget = "/config.Sconfig/Sget"
var WebPathSconfigSgroups = "/config.Sconfig/Sgroups"
var WebPathSconfigSapps = "/config.Sconfig/Sapps"

// SconfigWebClient is the client API for Sconfig service.
type SconfigWebClient interface {
	//one specific app's current info
	Sinfo(context.Context, *Sinforeq) (*Sinforesp, error)
	//set one specific app's config
	Sset(context.Context, *Ssetreq) (*Ssetresp, error)
	//rollback one specific app's config
	Srollback(context.Context, *Srollbackreq) (*Srollbackresp, error)
	//get one specific app's config
	Sget(context.Context, *Sgetreq) (*Sgetresp, error)
	//get all groups
	Sgroups(context.Context, *Sgroupsreq) (*Sgroupsresp, error)
	//get all apps
	Sapps(context.Context, *Sappsreq) (*Sappsresp, error)
}

type sconfigWebClient struct {
	cc *web.WebClient
}

//has race,will only return the first's call's client,the config will use the first call's config
func NewSconfigWebClient(globaltimeout time.Duration, selfgroup, selfname string, picker web.PickHandler, discover web.DiscoveryHandler) (SconfigWebClient, error) {
	cc, e := web.NewWebClient(globaltimeout, selfgroup, selfname, Group, Name, picker, discover)
	if e != nil {
		return nil, e
	}
	return &sconfigWebClient{cc: cc}, nil
}

func (c *sconfigWebClient) Sinfo(ctx context.Context, req *Sinforeq) (*Sinforesp, error) {
	if req == nil {
		return nil, fmt.Errorf("bad request:nil")
	}
	//empty check
	if len(req.Groupname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: groupname")
	}
	//empty check
	if len(req.Appname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: appname")
	}
	//gte check
	if float64(req.OpNum) < 0 {
		return nil, fmt.Errorf("bad request:gte check failed: op_num")
	}
	var header http.Header
	if realcrx, ok := ctx.(*web.Context); ok {
		header = realcrx.GetHeaders()
	}
	if header == nil {
		header = make(http.Header)
	}
	if md := metadata.GetAllMetadata(ctx); len(md) != 0 {
		d, _ := json.Marshal(md)
		header.Set("Metadata", common.Byte2str(d))
	}
	header.Set("Content-Type", "application/x-www-form-urlencoded")
	buf := bufpool.GetBuffer()
	if len(req.Groupname) != 0 {
		buf.Append("&")
		buf.Append("groupname")
		buf.Append("=\"")
		buf.Append(req.Groupname)
		buf.Append("\"")
	}
	if len(req.Appname) != 0 {
		buf.Append("&")
		buf.Append("appname")
		buf.Append("=\"")
		buf.Append(req.Appname)
		buf.Append("\"")
	}
	if req.OpNum != 0 {
		buf.Append("&")
		buf.Append("op_num")
		buf.Append("=")
		buf.Append(req.OpNum)
	}
	if buf.Len() > 0 {
		buf.Bytes()[0] = '?'
	}
	callback, e := c.cc.Get(ctx, 500000000, WebPathSconfigSinfo+buf.String(), header)
	bufpool.PutBuffer(buf)
	if e != nil {
		return nil, fmt.Errorf("call error:" + e.Error())
	}
	defer callback.Body.Close()
	data, e := io.ReadAll(callback.Body)
	if e != nil {
		return nil, fmt.Errorf("read response error:" + e.Error())
	}
	if callback.StatusCode/100 == 5 || callback.StatusCode/100 == 4 {
		return nil, fmt.Errorf(common.Byte2str(data))
	}
	resp := new(Sinforesp)
	if len(data) > 0 {
		if e = json.Unmarshal(data, resp); e != nil {
			return nil, fmt.Errorf("response data format errors" + e.Error())
		}
	}
	return resp, nil
}
func (c *sconfigWebClient) Sset(ctx context.Context, req *Ssetreq) (*Ssetresp, error) {
	if req == nil {
		return nil, fmt.Errorf("bad request:nil")
	}
	//empty check
	if len(req.Groupname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: groupname")
	}
	//empty check
	if len(req.Appname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: appname")
	}
	var header http.Header
	if realcrx, ok := ctx.(*web.Context); ok {
		header = realcrx.GetHeaders()
	}
	if header == nil {
		header = make(http.Header)
	}
	if md := metadata.GetAllMetadata(ctx); len(md) != 0 {
		d, _ := json.Marshal(md)
		header.Set("Metadata", common.Byte2str(d))
	}
	header.Set("Content-Type", "application/json")
	reqdata, _ := json.Marshal(req)
	callback, e := c.cc.Post(ctx, 500000000, WebPathSconfigSset, header, reqdata)
	if e != nil {
		return nil, fmt.Errorf("call error:" + e.Error())
	}
	defer callback.Body.Close()
	data, e := io.ReadAll(callback.Body)
	if e != nil {
		return nil, fmt.Errorf("read response error:" + e.Error())
	}
	if callback.StatusCode/100 == 5 || callback.StatusCode/100 == 4 {
		return nil, fmt.Errorf(common.Byte2str(data))
	}
	resp := new(Ssetresp)
	if len(data) > 0 {
		if e = json.Unmarshal(data, resp); e != nil {
			return nil, fmt.Errorf("response data format errors" + e.Error())
		}
	}
	return resp, nil
}
func (c *sconfigWebClient) Srollback(ctx context.Context, req *Srollbackreq) (*Srollbackresp, error) {
	if req == nil {
		return nil, fmt.Errorf("bad request:nil")
	}
	//empty check
	if len(req.Groupname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: groupname")
	}
	//empty check
	if len(req.Appname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: appname")
	}
	//empty check
	if len(req.Id) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: id")
	}
	var header http.Header
	if realcrx, ok := ctx.(*web.Context); ok {
		header = realcrx.GetHeaders()
	}
	if header == nil {
		header = make(http.Header)
	}
	if md := metadata.GetAllMetadata(ctx); len(md) != 0 {
		d, _ := json.Marshal(md)
		header.Set("Metadata", common.Byte2str(d))
	}
	header.Set("Content-Type", "application/json")
	reqdata, _ := json.Marshal(req)
	callback, e := c.cc.Post(ctx, 500000000, WebPathSconfigSrollback, header, reqdata)
	if e != nil {
		return nil, fmt.Errorf("call error:" + e.Error())
	}
	defer callback.Body.Close()
	data, e := io.ReadAll(callback.Body)
	if e != nil {
		return nil, fmt.Errorf("read response error:" + e.Error())
	}
	if callback.StatusCode/100 == 5 || callback.StatusCode/100 == 4 {
		return nil, fmt.Errorf(common.Byte2str(data))
	}
	resp := new(Srollbackresp)
	if len(data) > 0 {
		if e = json.Unmarshal(data, resp); e != nil {
			return nil, fmt.Errorf("response data format errors" + e.Error())
		}
	}
	return resp, nil
}
func (c *sconfigWebClient) Sget(ctx context.Context, req *Sgetreq) (*Sgetresp, error) {
	if req == nil {
		return nil, fmt.Errorf("bad request:nil")
	}
	//empty check
	if len(req.Groupname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: groupname")
	}
	//empty check
	if len(req.Appname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: appname")
	}
	//empty check
	if len(req.Id) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: id")
	}
	var header http.Header
	if realcrx, ok := ctx.(*web.Context); ok {
		header = realcrx.GetHeaders()
	}
	if header == nil {
		header = make(http.Header)
	}
	if md := metadata.GetAllMetadata(ctx); len(md) != 0 {
		d, _ := json.Marshal(md)
		header.Set("Metadata", common.Byte2str(d))
	}
	header.Set("Content-Type", "application/x-www-form-urlencoded")
	buf := bufpool.GetBuffer()
	if len(req.Groupname) != 0 {
		buf.Append("&")
		buf.Append("groupname")
		buf.Append("=\"")
		buf.Append(req.Groupname)
		buf.Append("\"")
	}
	if len(req.Appname) != 0 {
		buf.Append("&")
		buf.Append("appname")
		buf.Append("=\"")
		buf.Append(req.Appname)
		buf.Append("\"")
	}
	if len(req.Id) != 0 {
		buf.Append("&")
		buf.Append("id")
		buf.Append("=\"")
		buf.Append(req.Id)
		buf.Append("\"")
	}
	if buf.Len() > 0 {
		buf.Bytes()[0] = '?'
	}
	callback, e := c.cc.Get(ctx, 500000000, WebPathSconfigSget+buf.String(), header)
	bufpool.PutBuffer(buf)
	if e != nil {
		return nil, fmt.Errorf("call error:" + e.Error())
	}
	defer callback.Body.Close()
	data, e := io.ReadAll(callback.Body)
	if e != nil {
		return nil, fmt.Errorf("read response error:" + e.Error())
	}
	if callback.StatusCode/100 == 5 || callback.StatusCode/100 == 4 {
		return nil, fmt.Errorf(common.Byte2str(data))
	}
	resp := new(Sgetresp)
	if len(data) > 0 {
		if e = json.Unmarshal(data, resp); e != nil {
			return nil, fmt.Errorf("response data format errors" + e.Error())
		}
	}
	return resp, nil
}
func (c *sconfigWebClient) Sgroups(ctx context.Context, req *Sgroupsreq) (*Sgroupsresp, error) {
	if req == nil {
		return nil, fmt.Errorf("bad request:nil")
	}
	var header http.Header
	if realcrx, ok := ctx.(*web.Context); ok {
		header = realcrx.GetHeaders()
	}
	if header == nil {
		header = make(http.Header)
	}
	if md := metadata.GetAllMetadata(ctx); len(md) != 0 {
		d, _ := json.Marshal(md)
		header.Set("Metadata", common.Byte2str(d))
	}
	header.Set("Content-Type", "application/x-www-form-urlencoded")
	buf := bufpool.GetBuffer()
	if buf.Len() > 0 {
		buf.Bytes()[0] = '?'
	}
	callback, e := c.cc.Get(ctx, 500000000, WebPathSconfigSgroups+buf.String(), header)
	bufpool.PutBuffer(buf)
	if e != nil {
		return nil, fmt.Errorf("call error:" + e.Error())
	}
	defer callback.Body.Close()
	data, e := io.ReadAll(callback.Body)
	if e != nil {
		return nil, fmt.Errorf("read response error:" + e.Error())
	}
	if callback.StatusCode/100 == 5 || callback.StatusCode/100 == 4 {
		return nil, fmt.Errorf(common.Byte2str(data))
	}
	resp := new(Sgroupsresp)
	if len(data) > 0 {
		if e = json.Unmarshal(data, resp); e != nil {
			return nil, fmt.Errorf("response data format errors" + e.Error())
		}
	}
	return resp, nil
}
func (c *sconfigWebClient) Sapps(ctx context.Context, req *Sappsreq) (*Sappsresp, error) {
	if req == nil {
		return nil, fmt.Errorf("bad request:nil")
	}
	//empty check
	if len(req.Groupname) == 0 {
		return nil, fmt.Errorf("bad request:empty check failed: groupname")
	}
	var header http.Header
	if realcrx, ok := ctx.(*web.Context); ok {
		header = realcrx.GetHeaders()
	}
	if header == nil {
		header = make(http.Header)
	}
	if md := metadata.GetAllMetadata(ctx); len(md) != 0 {
		d, _ := json.Marshal(md)
		header.Set("Metadata", common.Byte2str(d))
	}
	header.Set("Content-Type", "application/x-www-form-urlencoded")
	buf := bufpool.GetBuffer()
	if len(req.Groupname) != 0 {
		buf.Append("&")
		buf.Append("groupname")
		buf.Append("=\"")
		buf.Append(req.Groupname)
		buf.Append("\"")
	}
	if buf.Len() > 0 {
		buf.Bytes()[0] = '?'
	}
	callback, e := c.cc.Get(ctx, 500000000, WebPathSconfigSapps+buf.String(), header)
	bufpool.PutBuffer(buf)
	if e != nil {
		return nil, fmt.Errorf("call error:" + e.Error())
	}
	defer callback.Body.Close()
	data, e := io.ReadAll(callback.Body)
	if e != nil {
		return nil, fmt.Errorf("read response error:" + e.Error())
	}
	if callback.StatusCode/100 == 5 || callback.StatusCode/100 == 4 {
		return nil, fmt.Errorf(common.Byte2str(data))
	}
	resp := new(Sappsresp)
	if len(data) > 0 {
		if e = json.Unmarshal(data, resp); e != nil {
			return nil, fmt.Errorf("response data format errors" + e.Error())
		}
	}
	return resp, nil
}

// SconfigWebServer is the server API for Sconfig service.
type SconfigWebServer interface {
	//one specific app's current info
	Sinfo(context.Context, *Sinforeq) (*Sinforesp, error)
	//set one specific app's config
	Sset(context.Context, *Ssetreq) (*Ssetresp, error)
	//rollback one specific app's config
	Srollback(context.Context, *Srollbackreq) (*Srollbackresp, error)
	//get one specific app's config
	Sget(context.Context, *Sgetreq) (*Sgetresp, error)
	//get all groups
	Sgroups(context.Context, *Sgroupsreq) (*Sgroupsresp, error)
	//get all apps
	Sapps(context.Context, *Sappsreq) (*Sappsresp, error)
}

func _Sconfig_Sinfo_WebHandler(handler func(context.Context, *Sinforeq) (*Sinforesp, error)) web.OutsideHandler {
	return func(ctx *web.Context) {
		req := new(Sinforeq)
		if ctx.GetMethod() != http.MethodGet && ctx.GetContentType() == "application/json" {
			data, e := ctx.GetBody()
			if e != nil {
				ctx.WriteString(http.StatusInternalServerError, "server error:read request body error:"+e.Error())
				return
			}
			if len(data) != 0 {
				if e := json.Unmarshal(data, req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:json format error:"+e.Error())
					return
				}
			}
		} else {
			if e := ctx.ParseForm(); e != nil {
				ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
				return
			}
			buf := bufpool.GetBuffer()
			buf.Append("{")
			hasfields := false
			if temp := ctx.GetForm("groupname"); len(temp) != 0 {
				buf.Append("\"groupname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if temp := ctx.GetForm("appname"); len(temp) != 0 {
				buf.Append("\"appname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if temp := ctx.GetForm("op_num"); len(temp) != 0 {
				buf.Append("\"op_num\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if hasfields {
				buf.Bytes()[buf.Len()-1] = '}'
			} else {
				buf.Append("}")
			}
			if buf.Len() > 2 {
				if e := json.Unmarshal(buf.Bytes(), req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
					return
				}
			}
			bufpool.PutBuffer(buf)
		}
		//empty check
		if len(req.Groupname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: groupname")
			return
		}
		//empty check
		if len(req.Appname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: appname")
			return
		}
		//gte check
		if float64(req.OpNum) < 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:gte check failed: op_num")
			return
		}
		resp, e := handler(ctx, req)
		if e != nil {
			ctx.WriteString(http.StatusInternalServerError, e.Error())
		} else if resp == nil {
			ctx.WriteString(http.StatusOK, "{}")
		} else {
			respd, _ := json.Marshal(resp)
			ctx.Write(http.StatusOK, respd)
		}
	}
}
func _Sconfig_Sset_WebHandler(handler func(context.Context, *Ssetreq) (*Ssetresp, error)) web.OutsideHandler {
	return func(ctx *web.Context) {
		req := new(Ssetreq)
		if ctx.GetMethod() != http.MethodGet && ctx.GetContentType() == "application/json" {
			data, e := ctx.GetBody()
			if e != nil {
				ctx.WriteString(http.StatusInternalServerError, "server error:read request body error:"+e.Error())
				return
			}
			if len(data) != 0 {
				if e := json.Unmarshal(data, req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:json format error:"+e.Error())
					return
				}
			}
		} else {
			if e := ctx.ParseForm(); e != nil {
				ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
				return
			}
			buf := bufpool.GetBuffer()
			buf.Append("{")
			hasfields := false
			if temp := ctx.GetForm("groupname"); len(temp) != 0 {
				buf.Append("\"groupname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if temp := ctx.GetForm("appname"); len(temp) != 0 {
				buf.Append("\"appname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if temp := ctx.GetForm("config"); len(temp) != 0 {
				buf.Append("\"config\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if hasfields {
				buf.Bytes()[buf.Len()-1] = '}'
			} else {
				buf.Append("}")
			}
			if buf.Len() > 2 {
				if e := json.Unmarshal(buf.Bytes(), req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
					return
				}
			}
			bufpool.PutBuffer(buf)
		}
		//empty check
		if len(req.Groupname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: groupname")
			return
		}
		//empty check
		if len(req.Appname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: appname")
			return
		}
		resp, e := handler(ctx, req)
		if e != nil {
			ctx.WriteString(http.StatusInternalServerError, e.Error())
		} else if resp == nil {
			ctx.WriteString(http.StatusOK, "{}")
		} else {
			respd, _ := json.Marshal(resp)
			ctx.Write(http.StatusOK, respd)
		}
	}
}
func _Sconfig_Srollback_WebHandler(handler func(context.Context, *Srollbackreq) (*Srollbackresp, error)) web.OutsideHandler {
	return func(ctx *web.Context) {
		req := new(Srollbackreq)
		if ctx.GetMethod() != http.MethodGet && ctx.GetContentType() == "application/json" {
			data, e := ctx.GetBody()
			if e != nil {
				ctx.WriteString(http.StatusInternalServerError, "server error:read request body error:"+e.Error())
				return
			}
			if len(data) != 0 {
				if e := json.Unmarshal(data, req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:json format error:"+e.Error())
					return
				}
			}
		} else {
			if e := ctx.ParseForm(); e != nil {
				ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
				return
			}
			buf := bufpool.GetBuffer()
			buf.Append("{")
			hasfields := false
			if temp := ctx.GetForm("groupname"); len(temp) != 0 {
				buf.Append("\"groupname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if temp := ctx.GetForm("appname"); len(temp) != 0 {
				buf.Append("\"appname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if temp := ctx.GetForm("id"); len(temp) != 0 {
				buf.Append("\"id\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if hasfields {
				buf.Bytes()[buf.Len()-1] = '}'
			} else {
				buf.Append("}")
			}
			if buf.Len() > 2 {
				if e := json.Unmarshal(buf.Bytes(), req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
					return
				}
			}
			bufpool.PutBuffer(buf)
		}
		//empty check
		if len(req.Groupname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: groupname")
			return
		}
		//empty check
		if len(req.Appname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: appname")
			return
		}
		//empty check
		if len(req.Id) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: id")
			return
		}
		resp, e := handler(ctx, req)
		if e != nil {
			ctx.WriteString(http.StatusInternalServerError, e.Error())
		} else if resp == nil {
			ctx.WriteString(http.StatusOK, "{}")
		} else {
			respd, _ := json.Marshal(resp)
			ctx.Write(http.StatusOK, respd)
		}
	}
}
func _Sconfig_Sget_WebHandler(handler func(context.Context, *Sgetreq) (*Sgetresp, error)) web.OutsideHandler {
	return func(ctx *web.Context) {
		req := new(Sgetreq)
		if ctx.GetMethod() != http.MethodGet && ctx.GetContentType() == "application/json" {
			data, e := ctx.GetBody()
			if e != nil {
				ctx.WriteString(http.StatusInternalServerError, "server error:read request body error:"+e.Error())
				return
			}
			if len(data) != 0 {
				if e := json.Unmarshal(data, req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:json format error:"+e.Error())
					return
				}
			}
		} else {
			if e := ctx.ParseForm(); e != nil {
				ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
				return
			}
			buf := bufpool.GetBuffer()
			buf.Append("{")
			hasfields := false
			if temp := ctx.GetForm("groupname"); len(temp) != 0 {
				buf.Append("\"groupname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if temp := ctx.GetForm("appname"); len(temp) != 0 {
				buf.Append("\"appname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if temp := ctx.GetForm("id"); len(temp) != 0 {
				buf.Append("\"id\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if hasfields {
				buf.Bytes()[buf.Len()-1] = '}'
			} else {
				buf.Append("}")
			}
			if buf.Len() > 2 {
				if e := json.Unmarshal(buf.Bytes(), req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
					return
				}
			}
			bufpool.PutBuffer(buf)
		}
		//empty check
		if len(req.Groupname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: groupname")
			return
		}
		//empty check
		if len(req.Appname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: appname")
			return
		}
		//empty check
		if len(req.Id) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: id")
			return
		}
		resp, e := handler(ctx, req)
		if e != nil {
			ctx.WriteString(http.StatusInternalServerError, e.Error())
		} else if resp == nil {
			ctx.WriteString(http.StatusOK, "{}")
		} else {
			respd, _ := json.Marshal(resp)
			ctx.Write(http.StatusOK, respd)
		}
	}
}
func _Sconfig_Sgroups_WebHandler(handler func(context.Context, *Sgroupsreq) (*Sgroupsresp, error)) web.OutsideHandler {
	return func(ctx *web.Context) {
		req := new(Sgroupsreq)
		if ctx.GetMethod() != http.MethodGet && ctx.GetContentType() == "application/json" {
			data, e := ctx.GetBody()
			if e != nil {
				ctx.WriteString(http.StatusInternalServerError, "server error:read request body error:"+e.Error())
				return
			}
			if len(data) != 0 {
				if e := json.Unmarshal(data, req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:json format error:"+e.Error())
					return
				}
			}
		} else {
			if e := ctx.ParseForm(); e != nil {
				ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
				return
			}
			buf := bufpool.GetBuffer()
			buf.Append("{")
			hasfields := false
			if hasfields {
				buf.Bytes()[buf.Len()-1] = '}'
			} else {
				buf.Append("}")
			}
			if buf.Len() > 2 {
				if e := json.Unmarshal(buf.Bytes(), req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
					return
				}
			}
			bufpool.PutBuffer(buf)
		}
		resp, e := handler(ctx, req)
		if e != nil {
			ctx.WriteString(http.StatusInternalServerError, e.Error())
		} else if resp == nil {
			ctx.WriteString(http.StatusOK, "{}")
		} else {
			respd, _ := json.Marshal(resp)
			ctx.Write(http.StatusOK, respd)
		}
	}
}
func _Sconfig_Sapps_WebHandler(handler func(context.Context, *Sappsreq) (*Sappsresp, error)) web.OutsideHandler {
	return func(ctx *web.Context) {
		req := new(Sappsreq)
		if ctx.GetMethod() != http.MethodGet && ctx.GetContentType() == "application/json" {
			data, e := ctx.GetBody()
			if e != nil {
				ctx.WriteString(http.StatusInternalServerError, "server error:read request body error:"+e.Error())
				return
			}
			if len(data) != 0 {
				if e := json.Unmarshal(data, req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:json format error:"+e.Error())
					return
				}
			}
		} else {
			if e := ctx.ParseForm(); e != nil {
				ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
				return
			}
			buf := bufpool.GetBuffer()
			buf.Append("{")
			hasfields := false
			if temp := ctx.GetForm("groupname"); len(temp) != 0 {
				buf.Append("\"groupname\":")
				buf.Append(temp)
				buf.Append(",")
				hasfields = true
			}
			if hasfields {
				buf.Bytes()[buf.Len()-1] = '}'
			} else {
				buf.Append("}")
			}
			if buf.Len() > 2 {
				if e := json.Unmarshal(buf.Bytes(), req); e != nil {
					ctx.WriteString(http.StatusBadRequest, "bad request:form format error:"+e.Error())
					return
				}
			}
			bufpool.PutBuffer(buf)
		}
		//empty check
		if len(req.Groupname) == 0 {
			ctx.WriteString(http.StatusBadRequest, "bad request:empty check failed: groupname")
			return
		}
		resp, e := handler(ctx, req)
		if e != nil {
			ctx.WriteString(http.StatusInternalServerError, e.Error())
		} else if resp == nil {
			ctx.WriteString(http.StatusOK, "{}")
		} else {
			respd, _ := json.Marshal(resp)
			ctx.Write(http.StatusOK, respd)
		}
	}
}
func RegisterSconfigWebServer(engine *web.WebServer, svc SconfigWebServer, allmids map[string]web.OutsideHandler) error {
	//avoid lint
	_ = allmids
	if e := engine.Get(WebPathSconfigSinfo, 500000000, _Sconfig_Sinfo_WebHandler(svc.Sinfo)); e != nil {
		return e
	}
	if e := engine.Post(WebPathSconfigSset, 500000000, _Sconfig_Sset_WebHandler(svc.Sset)); e != nil {
		return e
	}
	if e := engine.Post(WebPathSconfigSrollback, 500000000, _Sconfig_Srollback_WebHandler(svc.Srollback)); e != nil {
		return e
	}
	if e := engine.Get(WebPathSconfigSget, 500000000, _Sconfig_Sget_WebHandler(svc.Sget)); e != nil {
		return e
	}
	if e := engine.Get(WebPathSconfigSgroups, 500000000, _Sconfig_Sgroups_WebHandler(svc.Sgroups)); e != nil {
		return e
	}
	if e := engine.Get(WebPathSconfigSapps, 500000000, _Sconfig_Sapps_WebHandler(svc.Sapps)); e != nil {
		return e
	}
	return nil
}

// Code generated by protoc-gen-go-rpc. DO NOT EDIT.
// version:
// 	protoc-gen-rpc v0.0.1
// 	protoc         v3.17.3
// source: api/status_config.proto

package api

import (
	context "context"
	log "github.com/chenjie199234/Corelib/log"
	rpc "github.com/chenjie199234/Corelib/rpc"
	error1 "github.com/chenjie199234/Corelib/util/error"
	metadata "github.com/chenjie199234/Corelib/util/metadata"
	proto "google.golang.org/protobuf/proto"
)

var _StatusRpcCheckers map[string]func(req interface{}) string

func init() {
	_StatusRpcCheckers = make(map[string]func(req interface{}) string, 1)
	_StatusRpcCheckers["\"\\\"config/api\\\"\".Pingreq"] = func(r interface{}) string {
		req := r.(*Pingreq)
		if req.Timestamp <= 0 {
			return "field: timestamp in object: pingreq check value int gt failed"
		}
		return ""
	}
}

var _RpcPathStatusPing = "/config.status/ping"

type StatusRpcClient interface {
	//ping check server's health
	Ping(context.Context, *Pingreq) (*Pingresp, error)
}

type statusRpcClient struct {
	cc *rpc.RpcClient
}

func NewStatusRpcClient(c *rpc.ClientConfig, selfgroup, selfname, peergroup, peername string) (StatusRpcClient, error) {
	cc, e := rpc.NewRpcClient(c, selfgroup, selfname, peergroup, peername)
	if e != nil {
		return nil, e
	}
	return &statusRpcClient{cc: cc}, nil
}

func (c *statusRpcClient) Ping(ctx context.Context, req *Pingreq) (*Pingresp, error) {
	if req == nil {
		return nil, error1.ErrReq
	}
	if s := _StatusRpcCheckers["\"\\\"config/api\\\"\".Pingreq"](req); s != "" {
		log.Error("[/config.status/ping]", s)
		return nil, error1.ErrReq
	}
	reqd, _ := proto.Marshal(req)
	respd, e := c.cc.Call(ctx, 200000000, _RpcPathStatusPing, reqd, metadata.GetAllMetadata(ctx))
	if e != nil {
		return nil, error1.StdErrorToError(e)
	}
	resp := new(Pingresp)
	if len(respd) == 0 {
		return resp, nil
	}
	if e := proto.Unmarshal(respd, resp); e != nil {
		return nil, error1.ErrResp
	}
	return resp, nil
}

type StatusRpcServer interface {
	//ping check server's health
	Ping(context.Context, *Pingreq) (*Pingresp, error)
}

func _Status_Ping_RpcHandler(handler func(context.Context, *Pingreq) (*Pingresp, error)) rpc.OutsideHandler {
	return func(ctx *rpc.Context) {
		req := new(Pingreq)
		if e := proto.Unmarshal(ctx.GetBody(), req); e != nil {
			ctx.Abort(error1.ErrReq)
			return
		}
		if s := _StatusRpcCheckers["\"\\\"config/api\\\"\".Pingreq"](req); s != "" {
			log.Error("[/config.status/ping]", s)
			ctx.Abort(error1.ErrReq)
		}
		resp, e := handler(ctx, req)
		if e != nil {
			ctx.Abort(e)
			return
		}
		if resp == nil {
			resp = new(Pingresp)
		}
		respd, _ := proto.Marshal(resp)
		ctx.Write(respd)
	}
}
func RegisterStatusRpcServer(engine *rpc.RpcServer, svc StatusRpcServer, allmids map[string]rpc.OutsideHandler) error {
	//avoid lint
	_ = allmids
	if e := engine.RegisterHandler(_RpcPathStatusPing, 200000000, _Status_Ping_RpcHandler(svc.Ping)); e != nil {
		return e
	}
	return nil
}
